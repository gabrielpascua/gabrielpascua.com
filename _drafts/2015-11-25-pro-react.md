---
layout: book
title:  "Pro React"
excerpt: "Build complex front-end applications in a composable way with React 15"
date:   2015-11-25
categories: books
book_url: http://www.apress.com/9781484212615
book_image: /img/pro-react-350x499.jpg
tags: javascript, react
---

### 1. Getting Started
* Benefits of React:
    - Rendering is simple. React has an in-memory representation of the DOM which is supposedly faster to render and manipulate.
    - Component Oriented Development. Everything in React is a Component written in Javascript.
    - Flexible Abstraction of the DOM Model that promotes consistent behavior across different browsers and devices.
* Minimum React Project Folder Structure  
    <pre>

      source  
      |__ app.js  
      index.html
      package.json
      webpack.config.js
    </pre>

* Start a local server by running `node_modules/.bin/webpack-dev-server`
* Although you can inject your React components in the `document.body`, it isn't recommended because other libraries attach elements to it that may cause issues.
* React uses **props** to pass data from parent to child.  It cannot be changed from the child component. In JSX, **props** are passed as attributes.    
    `//JSX = <MyComponent quantity="1" name="test" />`  
    `{this.props.quantity} x {this.props.name}`
* To reference everything in between the opening and closing tag, use **props.children**.  
    `//JSX = <MyComponent quantity="1"/>CONTENT TO ACCESS</MyComponent>`  
    `{this.props.quantity} x {this.props.children}`
* **props** are immutable. **state** is what you need to update your components.  React uses `this.setState()` to change a components behavior and handle user interaction.  **state** is private to a component.
<p></p>

### 2. Inside the DOM Abstraction
* A single event listener is added to the root of the document that gets mapped to the appropriate element when the event is fired.  The event handler is removed when the component unmounts.
* JSX events and attributes are **camelCased** because as a Javascript language extension, it's built using the DOM API and not the HTML specs.  
* JSX Tags must have an opening and closing tag, or self-closed.
* You can create React elements in plain JavaScript using `React.createElement`.
* JSX components can only render a single root node because it is transformed to `React.createElement("h1", null, "Hello World");`.
* Conditional `if` and `switch` statements are not supported in JSX.  Use the ternary operator inline or move the expressions out to get around it.
* Javascript comment styles wrapped in `{}` are used in JSX and not the HTML syntax.
* React's built-in XSS protection will not allow you to generate or attach dynamic HTML.  Use the `dangerouslySetInnerHTML` property to bypass it.
* A React component's state should be kept to a minimum because the entire component is rendered when the state changes.
* React provides 2 ways of handling forms components:
    1.  **Controlled** - Any form component with a `value` property that gets reflected when rendered.  Controlled form components are uneditable by default and require component state handling to change the value.  Note that `textarea` and `select` use the `value` property to set default values.
    2.  **Uncontrolled** - Any form component without a `value` property and where user changes are handled without handling state.
* The unique identifier value of the `key` attribute allows fast lookup in React for components in a collection - `<Card key={card.id} ... />`
* Use the `ref` property if you need acccess to the rendered DOM element.  Use this sparingly becuase there's almost always a better way of representing a component before using this construct - `<input ref="myInput" />`.

### 3. Architecting Applications with Components
* 